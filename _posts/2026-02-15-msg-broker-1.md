---
title: 메시지 브로커와 Kafka - 1
description: 메시지 브로커의 등장 배경과 저장 구조 및 전달 모델 기준 분류 정리
author: lucas
date: 2026-02-15 18:00:00 +0900
categories: [Backend, Architecture]
tags: [message-broker, message-queue, pubsub, architecture]
pin: false
math: false
mermaid: false
---

## 1. 메시지 브로커의 개념

> **메시지 브로커(Message Broker)** 는  
> 프로듀서(Producer)와 컨슈머(Consumer) 사이에서 메시지를 중개하는 미들웨어이다.

브로커는 다음 역할을 수행한다.

- 메시지 저장
- 메시지 전달
- 라우팅
- 소비 관리
- 비동기 처리 지원


즉, 서비스 간 직접 통신 대신 **메시지를 매개로 느슨한 결합을 만드는 시스템**이다.

---

## 2. 메시지 브로커 등장 배경

### 2.1 기존 시스템의 문제
---

```
Service → HTTP/RPC → Service
```

- 동기 호출 병목
- 장애 전파
- 트래픽 증가 대응 어려움
- 서비스 간 강결합

위 문제로 인한 **비동기 처리 필요성**이 대두되었다.

---

### 2.2 메시지 브로커 등장
---

```
Producer → Broker(Queue) → Consumer
```

- 서비스 독립성 증가
- 트래픽 완충
- 비동기 처리 가능
- 시스템 확장 용이

이 구조에서 브로커는 **중앙 메시지 전달자** 역할을 한다.

---

### 2.3 Pub/Sub 모델의 등장
---
```
Producer → Topic → 여러 Consumer
```

서비스 수가 늘어남에 따라 다음을 필요로 하며, Pub/Sub 모델이 등장하였다.
- 이벤트 브로드캐스트
- 여러 서비스 반응
- 상태 변화 전달

---

###  2.4 메시지 브로커의 발전 흐름 정리

기존 시스템의 한계(2.1)를 해결하기 위해 메시지 기반 통신(2.2)이 등장하였고, 이 개념은 다음과 같은 흐름으로 발전하였다.

> **1990s — IBM MQ 등장**  
> 서로 다른 기업 시스템(메인프레임, ERP 등)을 안정적으로 연결하기 위해 메시지를 중간에 저장하고 전달하는 메시지 지향 미들웨어(MOM) 개념이 확립되었다.

> **2000s — RabbitMQ 등 MQ의 웹 서비스 도입**  
> 웹 서비스가 확산되면서 비동기 작업 처리와 서비스 분리를 위해 큐 기반 메시지 브로커(RabbitMQ, ActiveMQ 등)가 널리 사용되기 시작했다.

> **2010s — Kafka 등장 (로그 기반 메시징)**
> 대규모 서비스 환경에서 이벤트 히스토리 보존과 데이터 스트림 처리 필요성이 커지며 기존 MQ와 다른 로그 기반 메시징 시스템인 Kafka가 등장하였다.

이 흐름 속에서 메시지 브로커는 단순 작업 전달 시스템에서 이벤트 스트림 플랫폼으로 발전하게 되었다.

## 3. 메시지 브로커의 분류

> 메시징 시스템은 하나의 기준이 아니라 **저장 구조**와 **전달 모델**을 분리해서 이해해야 한다.


### 3.1 저장 구조에 따른 분류
---

| 구분 | Queue 기반 저장 | Log 기반 저장 |
| --- | --- | --- |
| 메시지 수명 | 처리 후 제거됨 | 로그에 유지됨 (보존 정책 기반 삭제) |
| 소비 상태 관리 | 브로커가 관리 | 소비자가 offset으로 관리 |
| 설계 목적 | 작업 전달 | 데이터 기록 |
| 처리 방식 | 한 번 처리 중심 | 여러 번 소비 가능 |
| 주요 활용 | 백그라운드 작업, 비동기 처리, 작업 분산 | 이벤트 스트림, 로그 저장, 데이터 파이프라인 |
| 재처리 | 어려움 | 기본적으로 가능 |
| 대표 시스템 | RabbitMQ, ActiveMQ, SQS | Kafka, Pulsar |

---

### 3.2 전달/소비 구조에 따른 분류
---

| 구분 | Queue 모델 (Competing Consumers) | Pub/Sub 모델 |
| --- | --- | --- |
| 메시지 소비 횟수 | 1번만 소비됨 | 여러 소비자가 각각 소비 |
| 소비 구조 | 소비자들이 경쟁하여 하나가 처리 | 각 소비자가 독립적으로 처리 |
| 메시지 전달 방식 | 작업을 누군가 처리하도록 전달 | 이벤트를 여러 곳에 전파 |
| 핵심 질문 | 누가 이 작업을 처리할 것인가 | 누가 이 이벤트에 반응할 것인가 |
| 시스템 목적 | 작업 분산, 비동기 처리 | 이벤트 브로드캐스트, 상태 전달 |
| 메시지 의미 | 해야 할 일 (To-do) | 발생한 사실 (Event) |
| 소비자 추가 시 영향 | 처리 속도 증가 (병렬 처리) | 메시지 수신 대상 증가 |
| 대표 활용 | 이메일 발송, 이미지 처리, 백그라운드 작업 | 알림 시스템, 로그 처리, 서비스 간 이벤트 전달 |

---

## 핵심 정리

> - 메시지 브로커는 메시지를 중개하는 시스템이다.
> - 메시지 큐는 브로커의 전달 모델 중 하나이다.
> - Pub/Sub도 전달 모델이다.
> - Queue는 작업 전달 중심 모델이다.
> - Pub/Sub은 이벤트 전달 중심 모델이다.
> - 메시징 시스템은 저장 구조와 소비 모델을 분리해서 이해해야 한다.
{: .prompt-tip }

---

## 참고 자료

1. [메시지 브로커의 등장 배경 이해](https://velog.io/@beberiche/Architecture-%EB%A9%94%EC%8B%9C%EC%A7%80-%ED%81%90%EC%99%80-%EB%A9%94%EC%8B%9C%EC%A7%80-%EB%B8%8C%EB%A1%9C%EC%BB%A4-MSA%EC%9D%98-%ED%95%B5%EC%8B%AC%EC%9A%94%EC%86%8C)
2. [메시지 브로커와 메시지 큐](https://blog.naver.com/mk_crew/222717343434)
3. [Redis를 MQ와 Pub/Sub 2가지 구조로 활용](https://velog.io/@jeongyeon_kim/Redis%EB%A0%88%EB%94%94%EC%8A%A4%EB%A5%BC-%EB%A9%94%EC%8B%9C%EC%A7%80-%EB%B8%8C%EB%A1%9C%EC%BB%A4%EB%A1%9C-%EC%82%AC%EC%9A%A9%ED%95%98%EA%B8%B0)
4. [Kafka의 본질 이해](https://velog.io/@ksk0605/Kafka-%EA%BC%AD-%EC%8D%A8%EC%95%BC-%ED%95%A0%EA%B9%8C-%EB%A9%94%EC%8B%9C%EC%A7%80-%ED%81%90%EB%A5%BC-%EB%84%98%EC%96%B4-%EC%9D%B4%EB%B2%A4%ED%8A%B8-%EB%A1%9C%EA%B7%B8%EB%A5%BC-%EC%84%A0%ED%83%9D%ED%95%98%EB%8A%94-%EC%9D%B4%EC%9C%A0)
